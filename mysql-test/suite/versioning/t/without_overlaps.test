create or replace table t(pk int, pstart date, pend date,
                          index(pk, pstart));

delimiter ~~;
create or replace procedure fill_table()
begin
  declare i int default 0;
  declare j date default '2000-01-01';

  while j < date '2010-01-01' do
    set i = 0;
    while i < 1000 do
      insert into t(pk, pstart, pend) values(i, j, adddate(j, interval 1 day));
      set i = i + 1;
    end while;
    set j = adddate(j, interval 1 day);
  end while;
end~~;
delimiter ;

begin; call fill_table(); commit;


create or replace function B(pk int, pstart date, pend date)
  returns bool
  return abs(datediff(pstart, date '2007-07-07')) =  pk*pk;

begin;
update t set pstart = adddate(pstart, interval 1 day),
             pend = adddate(pend, interval 1 day),
             pk = pk + 1
         where abs(datediff(pstart, date '2007-07-07')) =  pk*pk;
rollback;



create or replace temporary table tmp (pk int)
       select distinct pk+1 as pk from t
       where abs(datediff(pstart, date '2007-07-07')) =  pk*pk
       order by t.pk + 1;
alter table tmp add primary key(pk);

SELECT count(*) FROM (
 SELECT pk + 1 as new_pk,
        adddate(pstart, interval 1 day) as new_pstart,
        adddate(pend, interval 1 day) as new_pend
 FROM t
 WHERE abs(datediff(pstart, date '2007-07-07')) =  pk*pk
 UNION ALL
 SELECT pk as new_pk,
        pstart as new_pstart,
        pend as new_pend
 FROM t
 WHERE pk in (select pk as pk from tmp)
       and NOT (abs(datediff(pstart, date '2007-07-07')) =  pk*pk)
) AS s1 ORDER BY s1.new_pk, s1.new_pstart;


delimiter //
create or replace aggregate function ovl(s date, e date) returns date
begin
  declare ps date default s;
  declare pe date default e;
  declare continue handler for not found return '1111-1-1';
  loop
    insert into usrlog(s,e) values(s,e);
    fetch group next row;
    -- this is the only condition needed, because s > ps when sorted
    if s < pe then
      return s;
    end if;
    set ps = s;
    set pe = e;
  end loop;
end //
delimiter ;








SELECT new_pk, ovl(new_pstart, new_pend) FROM (
  SELECT pk + 1 as new_pk,
         adddate(pstart, interval 1 day) as new_pstart,
         adddate(pend, interval 1 day) as new_pend
  FROM t
  WHERE pk = 1 and abs(datediff(pstart, date '2007-07-07')) =  pk*pk
  UNION ALL
  SELECT pk as new_pk,
         pstart as new_pstart,
         pend as new_pend
  FROM t
  WHERE pk=2 and pk in (select pk as pk from tmp)
        and NOT (abs(datediff(pstart, date '2007-07-07')) =  pk*pk)
        and pstart > '2007-01-01' and pstart < '2007-12-12'
) AS s1 GROUP BY new_pk ORDER BY s1.new_pk, s1.new_pstart;

SELECT new_pk, new_pstart, new_pend FROM (
  SELECT pk + 1 as new_pk,
         adddate(pstart, interval 1 day) as new_pstart,
         adddate(pend, interval 1 day) as new_pend
  FROM t
  WHERE pk = 1 and abs(datediff(pstart, date '2007-07-07')) =  pk*pk
  UNION ALL
  SELECT pk as new_pk,
         pstart as new_pstart,
         pend as new_pend
  FROM t
  WHERE pk=2 and pk in (select pk as pk from tmp)
        and NOT (abs(datediff(pstart, date '2007-07-07')) =  pk*pk)
        and pstart > '2007-01-01' and pstart < '2007-12-12'
) as s1 ORDER BY s1.new_pk, s1.new_pstart;




select * from
  (select pk + 1 as pk,
          adddate(pstart, interval 1 day) as pstart,
          adddate(pend, interval 1 day) as pend
   from t
   where abs(datediff(t.pstart, date '2007-07-07')) =  t.pk*t.pk
  ) as s1
  inner join

  (select pk,
          pstart,
          pend
   from t
   where pk in (select pk from tmp) and not abs(datediff(pstart, date '2007-07-07')) =  pk*pk
  ) as s2
  on s1.pk = s2.pk and ((s1.pstart >= s2.pstart and s1.pstart < s2.pend)
                     or (s2.pstart >= s1.pstart and s2.pstart < s1.pend));
